{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 46, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/Ribhav/OneDrive/Documents/Projects/Major%20project%20final/localli/src/lib/prisma.ts"],"sourcesContent":["import { PrismaClient } from \"@prisma/client\";\r\n\r\nconst globalForPrisma = global as unknown as { prisma: PrismaClient };\r\n\r\nexport const prisma =\r\n  globalForPrisma.prisma ||\r\n  new PrismaClient({\r\n    log: [\"query\"],\r\n  });\r\n\r\nif (process.env.NODE_ENV !== \"production\")\r\n  globalForPrisma.prisma = prisma;\r\n"],"names":[],"mappings":";;;;AAAA;;AAEA,MAAM;AAEC,MAAM,SACX,gBAAgB,MAAM,IACtB,IAAI,sMAAY,CAAC;IACf,KAAK;QAAC;KAAQ;AAChB;AAEF,wCACE,gBAAgB,MAAM,GAAG"}},
    {"offset": {"line": 63, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/Ribhav/OneDrive/Documents/Projects/Major%20project%20final/localli/src/app/api/analytics/cluster-demand/route.ts"],"sourcesContent":["import { NextRequest, NextResponse } from \"next/server\";\nimport { prisma } from \"@/lib/prisma\";\n\ntype ClusterMetrics = {\n  clusterId: string;\n  currentDemandScore: number;\n  previousDemandScore: number;\n  growthRate: number;\n  isSurging: boolean;\n  latitude: number;\n  longitude: number;\n};\n\ntype ClusterAccumulator = {\n  totalPurchases: number;\n  totalCartAdds: number;\n  totalRevenue: number;\n};\n\ntype GeoAccumulator = {\n  latSum: number;\n  lngSum: number;\n  count: number;\n};\n\nfunction computeDemandScore(values: ClusterAccumulator): number {\n  return values.totalPurchases * 5 + values.totalCartAdds * 2 + values.totalRevenue * 0.1;\n}\n\nexport async function GET(request: NextRequest) {\n  try {\n    const { searchParams } = new URL(request.url);\n    const daysParam = searchParams.get(\"days\");\n\n    if (daysParam === null || daysParam.trim() === \"\") {\n      return NextResponse.json(\n        { message: \"days query parameter is required\" },\n        { status: 400 }\n      );\n    }\n\n    const days = Number(daysParam);\n    if (!Number.isFinite(days) || days <= 0) {\n      return NextResponse.json(\n        { message: \"days must be a positive number\" },\n        { status: 400 }\n      );\n    }\n\n    const now = new Date();\n    const currentStart = new Date(now.getTime() - days * 24 * 60 * 60 * 1000);\n    const previousStart = new Date(now.getTime() - 2 * days * 24 * 60 * 60 * 1000);\n\n    const [currentInteractions, previousInteractions, currentOrderItems, previousOrderItems] =\n      await Promise.all([\n        prisma.interactionLog.findMany({\n          where: {\n            action: {\n              in: [\"PURCHASE\", \"ADD_TO_CART\"],\n            },\n            createdAt: {\n              gte: currentStart,\n              lte: now,\n            },\n          },\n          select: {\n            action: true,\n            product: {\n              select: {\n                store: {\n                  select: {\n                    clusterId: true,\n                    lat: true,\n                    lng: true,\n                  },\n                },\n              },\n            },\n          },\n        }),\n        prisma.interactionLog.findMany({\n          where: {\n            action: {\n              in: [\"PURCHASE\", \"ADD_TO_CART\"],\n            },\n            createdAt: {\n              gte: previousStart,\n              lt: currentStart,\n            },\n          },\n          select: {\n            action: true,\n            product: {\n              select: {\n                store: {\n                  select: {\n                    clusterId: true,\n                    lat: true,\n                    lng: true,\n                  },\n                },\n              },\n            },\n          },\n        }),\n        prisma.orderItem.findMany({\n          where: {\n            order: {\n              createdAt: {\n                gte: currentStart,\n                lte: now,\n              },\n            },\n          },\n          select: {\n            price: true,\n            quantity: true,\n            product: {\n              select: {\n                store: {\n                  select: {\n                    clusterId: true,\n                    lat: true,\n                    lng: true,\n                  },\n                },\n              },\n            },\n          },\n        }),\n        prisma.orderItem.findMany({\n          where: {\n            order: {\n              createdAt: {\n                gte: previousStart,\n                lt: currentStart,\n              },\n            },\n          },\n          select: {\n            price: true,\n            quantity: true,\n            product: {\n              select: {\n                store: {\n                  select: {\n                    clusterId: true,\n                    lat: true,\n                    lng: true,\n                  },\n                },\n              },\n            },\n          },\n        }),\n      ]);\n\n    const currentClusterMap = new Map<string, ClusterAccumulator>();\n    const previousClusterMap = new Map<string, ClusterAccumulator>();\n    const clusterGeoMap = new Map<string, GeoAccumulator>();\n\n    for (const interaction of currentInteractions) {\n      const clusterId = interaction.product.store.clusterId;\n      const lat = interaction.product.store.lat;\n      const lng = interaction.product.store.lng;\n      const values = currentClusterMap.get(clusterId) ?? {\n        totalPurchases: 0,\n        totalCartAdds: 0,\n        totalRevenue: 0,\n      };\n\n      if (interaction.action === \"PURCHASE\") {\n        values.totalPurchases += 1;\n      } else if (interaction.action === \"ADD_TO_CART\") {\n        values.totalCartAdds += 1;\n      }\n\n      currentClusterMap.set(clusterId, values);\n\n      const geo = clusterGeoMap.get(clusterId) ?? {\n        latSum: 0,\n        lngSum: 0,\n        count: 0,\n      };\n\n      geo.latSum += lat ?? 0;\n      geo.lngSum += lng ?? 0;\n      geo.count += 1;\n      clusterGeoMap.set(clusterId, geo);\n    }\n\n    for (const orderItem of currentOrderItems) {\n      const clusterId = orderItem.product.store.clusterId;\n      const lat = orderItem.product.store.lat;\n      const lng = orderItem.product.store.lng;\n      const values = currentClusterMap.get(clusterId) ?? {\n        totalPurchases: 0,\n        totalCartAdds: 0,\n        totalRevenue: 0,\n      };\n\n      values.totalRevenue += orderItem.price * orderItem.quantity;\n      currentClusterMap.set(clusterId, values);\n\n      const geo = clusterGeoMap.get(clusterId) ?? {\n        latSum: 0,\n        lngSum: 0,\n        count: 0,\n      };\n\n      geo.latSum += lat ?? 0;\n      geo.lngSum += lng ?? 0;\n      geo.count += 1;\n      clusterGeoMap.set(clusterId, geo);\n    }\n\n    for (const interaction of previousInteractions) {\n      const clusterId = interaction.product.store.clusterId;\n      const values = previousClusterMap.get(clusterId) ?? {\n        totalPurchases: 0,\n        totalCartAdds: 0,\n        totalRevenue: 0,\n      };\n\n      if (interaction.action === \"PURCHASE\") {\n        values.totalPurchases += 1;\n      } else if (interaction.action === \"ADD_TO_CART\") {\n        values.totalCartAdds += 1;\n      }\n\n      previousClusterMap.set(clusterId, values);\n    }\n\n    for (const orderItem of previousOrderItems) {\n      const clusterId = orderItem.product.store.clusterId;\n      const values = previousClusterMap.get(clusterId) ?? {\n        totalPurchases: 0,\n        totalCartAdds: 0,\n        totalRevenue: 0,\n      };\n\n      values.totalRevenue += orderItem.price * orderItem.quantity;\n      previousClusterMap.set(clusterId, values);\n    }\n\n    const allClusterIds = new Set<string>([\n      ...Array.from(currentClusterMap.keys()),\n      ...Array.from(previousClusterMap.keys()),\n    ]);\n\n    const clusters: ClusterMetrics[] = Array.from(allClusterIds)\n      .map((clusterId) => {\n        const currentValues = currentClusterMap.get(clusterId) ?? {\n          totalPurchases: 0,\n          totalCartAdds: 0,\n          totalRevenue: 0,\n        };\n        const previousValues = previousClusterMap.get(clusterId) ?? {\n          totalPurchases: 0,\n          totalCartAdds: 0,\n          totalRevenue: 0,\n        };\n\n        const currentDemandScore = computeDemandScore(currentValues);\n        const previousDemandScore = computeDemandScore(previousValues);\n\n        let growthRate = 0;\n        if (previousDemandScore > 0) {\n          growthRate = ((currentDemandScore - previousDemandScore) / previousDemandScore) * 100;\n        } else if (currentDemandScore > 0) {\n          growthRate = 100;\n        }\n\n        const isSurging = growthRate >= 50 && currentDemandScore >= 20;\n        const geo = clusterGeoMap.get(clusterId);\n        const latitude = geo && geo.count > 0 ? geo.latSum / geo.count : 0;\n        const longitude = geo && geo.count > 0 ? geo.lngSum / geo.count : 0;\n\n        return {\n          clusterId,\n          currentDemandScore,\n          previousDemandScore,\n          growthRate,\n          isSurging,\n          latitude,\n          longitude,\n        };\n      })\n      .sort((a, b) => {\n        if (a.isSurging !== b.isSurging) {\n          return a.isSurging ? -1 : 1;\n        }\n\n        return b.growthRate - a.growthRate;\n      });\n\n    return NextResponse.json({ clusters }, { status: 200 });\n  } catch {\n    return NextResponse.json(\n      { message: \"Failed to compute cluster demand analytics\" },\n      { status: 500 }\n    );\n  }\n}\n"],"names":[],"mappings":"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"}}]
}