{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 46, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/Ribhav/OneDrive/Documents/Projects/Major%20project%20final/localli/src/lib/prisma.ts"],"sourcesContent":["import { PrismaClient } from \"@prisma/client\";\r\n\r\nconst globalForPrisma = global as unknown as { prisma: PrismaClient };\r\n\r\nexport const prisma =\r\n  globalForPrisma.prisma ||\r\n  new PrismaClient({\r\n    log: [\"query\"],\r\n  });\r\n\r\nif (process.env.NODE_ENV !== \"production\")\r\n  globalForPrisma.prisma = prisma;\r\n"],"names":[],"mappings":";;;;AAAA;;AAEA,MAAM;AAEC,MAAM,SACX,gBAAgB,MAAM,IACtB,IAAI,sMAAY,CAAC;IACf,KAAK;QAAC;KAAQ;AAChB;AAEF,wCACE,gBAAgB,MAAM,GAAG"}},
    {"offset": {"line": 63, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/Ribhav/OneDrive/Documents/Projects/Major%20project%20final/localli/src/app/api/analytics/cluster-competition/route.ts"],"sourcesContent":["import { NextResponse } from \"next/server\";\nimport { prisma } from \"@/lib/prisma\";\n\ntype ClusterCompetitionResult = {\n  clusterId: string;\n  totalVendors: number;\n  totalProducts: number;\n  demandScore: number;\n  competitionIndex: number;\n  opportunityScore: number;\n};\n\ntype ClusterAccumulator = {\n  vendorIds: Set<number>;\n  totalProducts: number;\n  totalPurchases: number;\n  totalCartAdds: number;\n  totalRevenue: number;\n};\n\nfunction getOrCreateClusterAccumulator(\n  clusterMap: Map<string, ClusterAccumulator>,\n  clusterId: string\n): ClusterAccumulator {\n  const existing = clusterMap.get(clusterId);\n  if (existing) {\n    return existing;\n  }\n\n  const created: ClusterAccumulator = {\n    vendorIds: new Set<number>(),\n    totalProducts: 0,\n    totalPurchases: 0,\n    totalCartAdds: 0,\n    totalRevenue: 0,\n  };\n  clusterMap.set(clusterId, created);\n  return created;\n}\n\nexport async function GET() {\n  try {\n    const [stores, products, interactions, orderItems] = await Promise.all([\n      prisma.store.findMany({\n        select: {\n          id: true,\n          clusterId: true,\n          vendorId: true,\n        },\n      }),\n      prisma.product.findMany({\n        select: {\n          id: true,\n          storeId: true,\n        },\n      }),\n      prisma.interactionLog.findMany({\n        where: {\n          action: {\n            in: [\"PURCHASE\", \"ADD_TO_CART\"],\n          },\n        },\n        select: {\n          action: true,\n          product: {\n            select: {\n              store: {\n                select: {\n                  clusterId: true,\n                },\n              },\n            },\n          },\n        },\n      }),\n      prisma.orderItem.findMany({\n        select: {\n          price: true,\n          quantity: true,\n          product: {\n            select: {\n              store: {\n                select: {\n                  clusterId: true,\n                },\n              },\n            },\n          },\n        },\n      }),\n    ]);\n\n    const clusterMap = new Map<string, ClusterAccumulator>();\n\n    const storeClusterById = new Map<number, string>();\n    for (const store of stores) {\n      storeClusterById.set(store.id, store.clusterId);\n      const acc = getOrCreateClusterAccumulator(clusterMap, store.clusterId);\n      acc.vendorIds.add(store.vendorId);\n    }\n\n    for (const product of products) {\n      const clusterId = storeClusterById.get(product.storeId);\n      if (!clusterId) {\n        continue;\n      }\n\n      const acc = getOrCreateClusterAccumulator(clusterMap, clusterId);\n      acc.totalProducts += 1;\n    }\n\n    for (const interaction of interactions) {\n      const clusterId = interaction.product.store.clusterId;\n      const acc = getOrCreateClusterAccumulator(clusterMap, clusterId);\n\n      if (interaction.action === \"PURCHASE\") {\n        acc.totalPurchases += 1;\n      } else if (interaction.action === \"ADD_TO_CART\") {\n        acc.totalCartAdds += 1;\n      }\n    }\n\n    for (const orderItem of orderItems) {\n      const clusterId = orderItem.product.store.clusterId;\n      const acc = getOrCreateClusterAccumulator(clusterMap, clusterId);\n      acc.totalRevenue += orderItem.price * orderItem.quantity;\n    }\n\n    const clusters: ClusterCompetitionResult[] = Array.from(clusterMap.entries())\n      .map(([clusterId, acc]) => {\n        const totalVendors = acc.vendorIds.size;\n        const demandScore =\n          acc.totalPurchases * 5 + acc.totalCartAdds * 2 + acc.totalRevenue * 0.1;\n        const competitionIndex = totalVendors * 2 + acc.totalProducts;\n        const opportunityScore = demandScore / (competitionIndex + 1);\n\n        return {\n          clusterId,\n          totalVendors,\n          totalProducts: acc.totalProducts,\n          demandScore,\n          competitionIndex,\n          opportunityScore,\n        };\n      })\n      .sort((a, b) => b.opportunityScore - a.opportunityScore);\n\n    return NextResponse.json({ clusters }, { status: 200 });\n  } catch {\n    return NextResponse.json(\n      { message: \"Failed to compute cluster competition analytics\" },\n      { status: 500 }\n    );\n  }\n}\n\n"],"names":[],"mappings":"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"}}]
}